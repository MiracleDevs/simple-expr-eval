/*
 * Simple expression parser and evaluator
 * https://github.com/MiracleDevs/simple-expr-eval
 * 
 * Copyright (c) 2018 Miracle Devs
 * Use, reproduction, distribution, and modification of this code is subject to the terms and
 * conditions of the MIT license, available at http://www.opensource.org/licenses/mit-license.php
 */
!function (t) { var e = { Unknown: "Unknown", Integer: "Integer", String: "String", Bool: "Bool", Null: "Null", Variable: "Variable", Equals: "Equals", NotEquals: "NotEquals", Lt: "Lt", Lte: "Lte", Gt: "Gt", Gte: "Gte", And: "And", Or: "Or", Group: "Group" }; function r(t, r) { if (!e[r]) throw new Error("Token " + r + " is not defined"); this.value = t, this.type = r } function n(t, e, r) { this.operator = t, this.left = e, this.right = r } function o(t, e, r) { n.call(this, t, e, r) } function l(t, e, r) { n.call(this, t, e, r) } function u(t, e, r) { n.call(this, t, e, r) } function a(t, e, r) { n.call(this, t, e, r) } function i(t) { this.value = t } function s(t) { i.call(this, t) } function p(t) { i.call(this, t) } o.prototype = Object.create(n.prototype), o.prototype.constructor = o, l.prototype = Object.create(n.prototype), l.prototype.constructor = l, u.prototype = Object.create(n.prototype), u.prototype.constructor = u, a.prototype = Object.create(n.prototype), a.prototype.constructor = a, s.prototype = Object.create(i.prototype), s.prototype.constructor = s, p.prototype = Object.create(i.prototype), p.prototype.constructor = p, t.simpleExprEval = function (t, c) { return function t(r, o) { if (o = o || {}, r instanceof n) return function (r, n) { switch (r.operator.type) { case e.Equals: return t(r.left, n) === t(r.right, n); case e.NotEquals: return t(r.left, n) !== t(r.right, n); case e.Lt: return t(r.left, n) < t(r.right, n); case e.Lte: return t(r.left, n) <= t(r.right, n); case e.Gt: return t(r.left, n) > t(r.right, n); case e.Gte: return t(r.left, n) >= t(r.right, n); case e.And: return !1 !== t(r.left, n) && t(r.right, n); case e.Or: return !0 === t(r.left, n) || t(r.right, n) }throw new Error(r.toString()) }(r, o); if (r instanceof i) return function (t, r) { switch (t.value.type) { case e.Integer: return parseInt(t.value.value); case e.String: return t.value.value; case e.Bool: if ("true" === t.value.value) return !0; if ("false" === t.value.value) return !1; throw new Error("Invalid boolean value: " + t.value.value); case e.Null: return null; case e.Variable: var n = r[t.value.value.substr(1)]; return void 0 === n ? null : n }throw new Error(t.toString()) }(r, o); throw new Error((node, node.toString())) }(function t(n) { var i = 0; function c(t) { if (t.type == e.Integer || t.type == e.String || t.type == e.Bool || t.type == e.Null) return new p(t); if (t.type == e.Variable) return new s(t); if (t.type == e.Group) return parseAux(t.tokens); throw new Error("Unexpected token " + t.Value) } return function () { var s = [], p = null; for (i = 0; i < n.length; i++) { var f = n[i]; if (f.type != e.Or) { var h = null; f.type == e.Group && (h = t(f.value)), f.type == e.Gt || f.type == e.Gte || f.type == e.Lt || f.type == e.Lte ? h = new a(f, c(n[i - 1]), c(n[i + 1])) : f.type != e.Equals && f.type != e.NotEquals || (h = new u(f, c(n[i - 1]), c(n[i + 1]))), null != h && (p = null != p ? new l(new r("&&", e.And), p, h) : h) } else null != p && (s.push(p), p = null) } null != p && (s.push(p), p = null); for (var g = null, y = 0; y < s.length; y++)g = null != g ? new o(new r("||", e.Or), g, s[y]) : s[y]; return g }() }(function t(n) { for (var o = [], l = 0; l < n.length; l++)if ("" != n[l].trim()) { var u = e.Unknown, a = ""; if ("(" == n[l]) { for (var i, s = l, p = 0, c = s + 1; c < n.length;) { var f = n[c]; if ("(" == f) p++; else if (")" == f) { if (0 == p) { i = c; break } p-- } c++ } a = t(n.substring(s + 1, i)), u = e.Group, l = i } else if (/^\d+$/.test(n[l])) for (u = e.Integer, a += n[l]; l + 1 < n.length && /^\d+$/.test(n[l + 1]);)a += n[++l]; else if ("'" === n[l] || '"' === n[l]) { var h = n[l]; for (u = e.String; l + 1 < n.length && n[l + 1] != h;)a += n[++l]; l++ } else if ("$" == n[l]) for (u = e.Variable, a += "$"; l + 1 < n.length && /[a-zA-Z0-9_]/.test(n[l + 1]);)a += n[++l]; else if ("!" == n[l] && l + 1 < n.length && "=" == n[l + 1]) u = e.NotEquals, a = "!=", l++; else if ("=" == n[l] && l + 1 < n.length && "=" == n[l + 1]) u = e.Equals, a = "==", l++; else if ("<" == n[l]) l + 1 < n.length && "=" == n[l + 1] ? (u = e.Lte, a = "<=", l++) : (u = e.Lt, a = "<"); else if (">" == n[l]) l + 1 < n.length && "=" == n[l + 1] ? (u = e.Gte, a = ">=", l++) : (u = e.Gt, a = ">"); else if ("&" == n[l] && l + 1 < n.length && "&" == n[l + 1]) u = e.And, a = "&&", l++; else if ("|" == n[l] && l + 1 < n.length && "|" == n[l + 1]) u = e.Or, a = "||", l++; else for (var g = n[l]; l + 1 < n.length;) { if ("true" == (g += n[++l]) || "false" == g) { u = e.Bool, a = g; break } if ("null" == g) { u = e.Null, a = "null"; break } } if (u == e.Unknown) throw new Error("Unknown token " + a); o.push(new r(a, u)) } return o }(t)), c) } }(this);